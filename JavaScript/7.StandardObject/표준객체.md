참고한 URL: http://www.tcpschool.com/javascript/js_standard_object

> 전역 객체(global object)
  - 자바스크립트에 미리 정의된 객체로 전역 프로퍼티나 전역 함수를 담는 공간의 역할을 함
  - 전역 객체는 전역 범위(global scope)에서 this연산자를 통해 접근함
  - 모든 객체는 전역 객체의 프로퍼티가 됨

> 래퍼 객체(wrapper object)
  - 숫자, 문자열, 불리언 등 원시 타입의 프로퍼티에 접근하려고 할 때 생성되는 임시 객체를 래퍼 객체라고 함
 
```
//str은 래퍼객체로 된다.
let str="문자열";    //문자열 리터럴 생성
let len=str.length; //문자열 프로퍼티인 length 사용

let strObj = new String(str);//문자열 객체 생성

str == strObj   //동등 연산자는 리터럴 값과 해당 래퍼 객체를 동일하게 봄
str === strObj  //일치 연산자는 리터럴 값과 해당 래퍼 객체를 구별

typeof str;     //string 타입
typeof strObj;  //object 타입
```

> 표준 객체(Standard Object)
  - 다른 객체의 기초가 되는 핵심적인 객체
  - 표준 객체 목록, [Number math date String Array]

> Number 객체
  - 자바스크립트에서 모든 숫자는 IEEE 754 국제 표준에서 정의한 64비트 부동 소수점 수로 저장됨
  - 0~51비트> 총 52비트는 가수 부분, 52~62비트> 총11비트의 지수 부분, 63비트> 총 1비트의 부호 부분
  - 64비트 부동 소수점 수의 정밀도는 정수부 15자리까지, 소수부는 17자리까지만 유효

```
let x = 999999999999999;  // 15자리의 정수부
let y = 9999999999999999; // 16자리의 정수부
let z = 0.1 + 0.2

x; // 999999999999999
y; // 10000000000000000
z; // 0.30000000000000004 오차 발생
```
  - 오차를 없애는 아래의 코드
```
let z = (0.2*10 + 0.1*10)/10; // 0.3
```
  - 진법 표현
    + 기본값은 10진법으로 표현
    + 0x접두사를 사용하여 16진법으로 수를 표현할 수 있음
    
```
let x = 0xAB; //16진법으로 표현된 10진수 171
let y = 29;   //10진법으로 표현된 10진수 29

x + y;        //두 수 모두 10진법으로 자동으로 변환되어 계산됨 -> 200

let num = 256;
num.toString(2);  //2진법으로 변환: 100000000
num.toString(8);  //8진법으로 변환: 400
num.toString(10); //10진법으로 변환: 256
num.toString(16); //16진법으로 변환: 100

//2진수로 변환한 결괏값을 문자열로 반환함.
num.toString(2); //100000000

//문자열을 숫자로 나눴기 때문에 자동으로 10진수로 변환되어 산술 연산된 결괏값
(num.toString(2)/2); //50000000
```
  - Infinity
    + 양의 무한대를 의미하는 Infinity값과 음의 무한대를 의미하는 -Infinity값을 사용
    + Infinity값은 사용자가 임의로 수정할 수 없는 읽기 전용 값, 자바스크립트의 어떤 수보다도 큰 수로 취급

```
let x = 10 /0;  //숫자를 0으로 나누면 Infinity를 반환
let y = Infinity * 1000 //Infinity에 어떠한 수를 산술 연산해도 Infinity를 반환
let z = 1/Infinity  //Infinity의 역수는 0을 반환
x;  //infinity
y;  //infinity
z;  //0
```

  - NaN
    + Not A Number의 약자, 숫자가 아니라는 의미로, 정의되지 않은 값이나 표현할 수 없는 값을 가리킴
    + 0을 0으로 나누거나, 숫자로 변환할 수 없는 피연산자로 산술 연산을 시도하는 경우 반환되는 읽기 전용 값

```
let x = 100 - "10";
let y = 100 - "문자열";
let z = 0/0;

x; //90, 문자열로 된 숫자는 자동으로 형변환되어 계산됨
y; //NaN, 순수하게 문자열로 된것은 숫자로 변환되지 않아서 연산되지 않기 때문에 NaN을 반환
z; //NaN, 0을 0으로 나눌 수 없어 NaN을 반환


//isNaN함수 활용하여 숫자인지 아닌지 판단
let x = 100*"문자열";
if(isNaN(x)) {
  console.log("변수 x의 값은 숫자가 아닙니다.");
} else {
  console.log("변수 x의 값은 숫자입니다.");
}
```
  - null, undefined, NaN, Infinity에 대한 비교
    + null은 Object타입이며, 아직 값이 정해지지 않은 것을 의미
    + undefined는 null과 달리 하나의 타입이며, 타입이 정해지지 않은 것을 의미
    + NaN은 number타입이며, 숫자가 아님을 의미
    + Infinity는 number타입이며, 무한대를 의미하는 숫자

```
typeof null; //Object
typeof undefined; //undefined
typeof NaN; //number
typeof Infinity; //number

Boolean(null);  //false
Boolean(undefined)  //false
Boolean(NaN); //false
Boolean(Infinity);  //true

Number(null); //0
Number(undefined);  //NaN
Number(NaN);  //NaN
Number(Infinity); //Infinity

String(null); //null
String(undefined);  //undefined
String(NaN);  //NAN
String(Infinity); //Infinity
```

  - Number 객체
    + 숫자는 보통 숫자 리터럴을 사용하여 표현
    + 수를 나타날 때 new 연산자를 사용하여 명시적으로 Number 객체를 생성, Number 객체는 숫자 값을 감싸고 있는 래퍼(wrapper)객체

```
let x = 100;  //숫자 리터럴
let y = new Number(100);  //Number 객체
x;  //100
y;  //100
typeof x; //number 타입
typeof y; //object 타입

x
```

  - Number 메소드
    + Number 객체에 정의되어 있는 숫자와 관련된 작업을 할 때 사용하는 메소드임
    + 가장 많이 사용되는 대표적인 Number 메소드
```
Number.parseFloat()
Number.parseInt()
Number.isNaN()
Number.isFinite()
Number.isInteger()
Number.isSafeInteger()
```
  - Number.parseFloat() 메소드
    + 문자열을 파싱(parsing)하여, 문자열에 포함된 숫자 부분을 실수 형태로 반환, 문자열에 여러 개의 숫자가 존재할 시 그 중 첫 번째 숫자만을 실수 형태로 반환

```
Number.parseFloat("12");  //12
Number.parseFloat("12.34"); //12.34
Number.parseFloat("12문자열"); //12
Number.parseFloat("12 34 56"); //12
Number.parseFloat("문자열 56");  //NaN
```
  - Number.parseInt() 메소드
    + 문자열을 파싱하여, 문자열에 포함된 숫자 부분을 정수 형태로 반환
    + 문자열에 여러 개의 숫자가 존재하면, 그 중에서 첫 번째 숫자만을 정수 형태로 반환

```
Number.parseInt("12") //12
Number.parseInt("12.34")  //12
Number.parseInt("12문자열"); //12
Number.parseInt("12 34 56");  //12
Number.parseInt("문자열 56");  //NaN
```
  - Number.isNaN()메소드
    + 전달된 값이 NaN인지 아닌지를 검사
    + 오직 숫자인 값에서만 동작, 그 값이 NaN인 경우에만 true를 반환
    + 전역함수 isNaN()을 사용시 강제로 숫자변환해주는 것을 방지하기 위함
```
Number.isNaN(NaN);  //true
Number.isNaN(0/0);  //true
//전역함수에서는 잘못된 결과를 반환함
isNaN("NaN");       //true
isNAN(undefined);   //true
isNaN("문자열");    //true
//Number.isNaN()메소드 사용시 맞는 결과를 반환
Number.isNaN("NaN");  //false
Number.isNAN(undefined);  //false
Number.isNaN("문자열");  //false
```
  - Number.isFinite() 메소드
    + 전달된 값이 유한한 수인지 아닌지를 검사
    + 오직 셀 수 있는 유한한 값만 동작, true반환
    + 전역함수isFinite()처럼 전달된 값을 숫자로 강제변환 하지 않음

```
Number.isFinite(0);   //true
Number.isFinite(3e45);  //true
Number.isFinite(Infinity);  //false
Number.isFinite(NaN);    //false
//다음은 전역 함수인 isFinite()에서 잘못된 결과를 반환함
isFinite(0);  //true
isFinite(null); //true
//Number.isFinite()메소드에서는 맞는 결과를 반환
Number.isFinite("0"); //false
Number.isFinite(null);  //false
```

  - Number.isInteger()메소드
    + 전달된 값이 정수인지 아닌지를 검사
    + 전달된 값이 정수이면 true 반환, 정수가 아니거나 NaN, Infinity와 같은 값은 모두 false를 반환

```
Number.isInteger(0);  //true
Number.isInteger(-100); //true
Number.isInteger(0.1);  //false
Number.isInteger("문자열");  //false
Numer.isInteger(Infinity);  //false
Number.isInteger(true); //false
```

  - Number.isSafeInteger()메소드
    + 전달된 값이 안전한 정수(safe integer)인지 아닌지를 검사
    + 안전한 정수(safe integer)란 IEEE 754국제 표준에서 정의한 64비트 부동 소수점 수로 정확히 표현되는 정수를 의미, -(2^53 -1)부터(2^53-1)까지의 모든 정수가 안전한 정수에 포함

```
//Math,pow()는 거듭제곱 연산을 수행하는 Math객체의 메소드
Number.isSafeInteger(10); //true
Number.isSafeInteger(Math.pow(2,53)-1); //true
Number.isSafeInteger(Math.pow(2,53)); //true
Number.isSafeInteger(Infinity); //false
```

  - 자바바스크립트 Number 메소드

```
Number.parseFloat() //문자열을 파싱하여, 문자열에 포함된 숫자 부분을 실수 형태로 반환
Number.parseInt() //문자열을 파싱하여, 문자열에 포함된 숫자 부분을 정수 형태로 반환
Number.isNaN()  //전달된 값이 NaN인지 아닌지를 검사
Number.isFinite() //전달된 값이 유한한 수인지 아닌지를 검사
Number.isInteger()  //전달된 값이 정수인지 아닌지를 검사
Number.isSafeInteger()  //전달된 값이 안전한 정수(safe integer)인지 아닌지를 검사
```

  - Number.prototype 메소드
    + 모든 Number인스턴스는 Number.prototype으로부터 메소드와 프로퍼티를 상속받음
    + 가장 많이 사용되는 대표적인 Number.prototype메소드는 다음과 같음
   
```
Number.prototype.toExponential()
Number.prototype.toFixed()
Number.prototype.toPrecision()
Number.prototype.toString()
Number.prototype.valueOf()
```

  - toExponential() 메소드
    + Number 인스턴스의 값을 지수 표기법으로 변환한 후, 그 값을 문자열을 반환
    + 전달받은 값은 지수 표기법에서 소수 부분의 자릿수로 사용
    
```
numObj.toExponential([소수부분의자릿수])

var num = 12.3456;    //Number 인스턴스를 생성
num.toExponential();  //1.23456e + 1
num.toExponential(2); //1.23e + 1
num.toExponential(4); //1.2346e + 1
12.3456.toExponential();  //1.23456e + 1
```
  - toFixed() 메소드
    + Number 인스턴스의 소수 부분 자릿수를 전달받은 값으로 고정한 후, 그 값을 문자열로 반환

```
numObj.toFixed([소수부분의자릿수])

var num = 3.14159265  //Number 인스턴스를 생성
num.toFixed();  //3
num.toFixed(2);  //3.14
num.toFixed(4); //3.1416
3.14159265.toFixed(6);  //3.141593
```
  - toPrecision()메소드
    + Number인스턴스의 가수와 소수 부분을 합친 자릿수를 전달받은 값으로 고정한 후, 그 값을 문자열로 반환

```
numObj.toPrecision([전체자릿수])

var num = 3.14159265; //Number 인스턴스를 생성
num.toPrecision();  //3.14159265
num.toPrecision(2); //3.1
num.toPrecision(4); //3.142
3.14159265.toPrecision(6);  //3.14159
```
  - toString()메소드
    + Number 인스턴스의 값을 문자열로 반환
    + 전달받은 값에 해당하는 진법으로 우선 값을 변환한 후, 그 값을 문자열로 반환

```
numObj.toString([진법])

var num = 255;  //Number 인스턴스를 생성
num.toString(); //255
(255).toString(); //255
(3.14).toString();  //3.14
num.toString(2);  //11111111
(100).toString(16); //64
(-0xff).toString(2);  //-11111111
```
  - valueOf()메소드
    + numObj.vallueOf()

```
var numObj = new Number(123); //123의 값을 가지는 Number 인스턴스를 생성
typeof numObj;  //object
var num = numObj.valueOf();
num;  //123
typeof num; //number
```
  - 자바스크립트 Number.prototype메소드
    + toExponential(): Number 인스턴스를 지수 표기법으로 반환한 후, 그 값을 문자열로 반환
    + toFixed(): Number 인스턴스의 소수 부분 자릿수를 전달받은 값으로 고정한 후, 그 값을 문자열로 반환
    + toPrecision(): Number 인스턴스의 가수와 소수 부분의 합친 자릿수를 전달받은 값으로 고정한 후, 그 값을 문자열로 반환
    + toString(): Number 인스턴스의 값을 문자열로 반환
    + valueOf(): Number 인스턴스가 가지고 있는 값을 반환

  - Math 객체
    + 
